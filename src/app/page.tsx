
"use client";

import { useState, useEffect, useCallback } from "react";
import type { Task, TaskPriority } from "@/types";
import { suggestOptimalTaskOrder, type TaskListInput, type TaskListOutput } from "@/ai/flows/suggest-optimal-task-order";
import AppHeader from "@/components/AppHeader";
import TaskList from "@/components/TaskList";
import ProgressIndicator from "@/components/ProgressIndicator";
import { useToast } from "@/hooks/use-toast";
import { v4 as uuidv4 } from 'uuid'; // Still useful for local-only fallback if Supabase isn't configured
import { supabase } from '@/lib/supabase';

// Sample initial tasks if Supabase is empty or not configured
const initialTasksSeed: Omit<Task, 'id' | 'createdAt'>[] = [
  { description: "Morning workout session", estimatedCompletionTime: 45, priority: 'medium', completed: true, orderIndex: 0 },
  { description: "Respond to urgent emails", estimatedCompletionTime: 60, priority: 'high', completed: false, orderIndex: 1 },
  { description: "Draft project proposal", estimatedCompletionTime: 120, priority: 'high', completed: false, orderIndex: 2 },
  { description: "Grocery shopping", estimatedCompletionTime: 75, priority: 'low', completed: false, orderIndex: 3 },
];

const TASKS_TABLE = "tasks";

export default function HomePage() {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [isClient, setIsClient] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [isScheduling, setIsScheduling] = useState(false);
  const { toast } = useToast();

  const mapSupabaseRowToTask = (row: any): Task => {
    return {
      id: row.id,
      description: row.description,
      estimatedCompletionTime: row.estimatedCompletionTime,
      priority: row.priority,
      completed: row.completed,
      createdAt: row.createdAt ? Date.parse(row.createdAt) : Date.now(), // Convert ISO string to ms
      orderIndex: row.orderIndex,
    };
  };

  const loadTasksFromSupabase = useCallback(async () => {
    setIsLoading(true);
    try {
      const { data, error } = await supabase
        .from(TASKS_TABLE)
        .select('*')
        .order('orderIndex', { ascending: true });

      if (error) throw error;

      let fetchedTasks: Task[] = data ? data.map(mapSupabaseRowToTask) : [];

      if (fetchedTasks.length === 0 && initialTasksSeed.length > 0) {
        // Seed Supabase if empty
        const tasksToSeed = initialTasksSeed.map((taskSeed, index) => ({
          // id will be auto-generated by Supabase
          description: taskSeed.description,
          estimatedCompletionTime: taskSeed.estimatedCompletionTime,
          priority: taskSeed.priority,
          completed: taskSeed.completed,
          // createdAt will be set by Supabase default now()
          orderIndex: index,
        }));

        const { error: insertError } = await supabase.from(TASKS_TABLE).insert(tasksToSeed);
        if (insertError) throw insertError;

        // Re-fetch after seeding
        const { data: seededData, error: fetchSeededError } = await supabase
          .from(TASKS_TABLE)
          .select('*')
          .order('orderIndex', { ascending: true });
        if (fetchSeededError) throw fetchSeededError;
        fetchedTasks = seededData ? seededData.map(mapSupabaseRowToTask) : [];
        toast({ title: "Welcome!", description: "Sample tasks loaded into Supabase." });
      }
      setTasks(fetchedTasks);
    } catch (error) {
      console.error("Error loading tasks from Supabase:", error);
      toast({ title: "Error", description: "Could not load tasks.", variant: "destructive" });
    } finally {
      setIsLoading(false);
    }
  }, [toast]);

  useEffect(() => {
    setIsClient(true);
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

    if (typeof window !== "undefined" && supabaseUrl && supabaseUrl !== 'your_supabase_url_here' && supabaseAnonKey && supabaseAnonKey !== 'your_supabase_anon_key_here') {
        loadTasksFromSupabase();
    } else if (supabaseUrl === 'your_supabase_url_here' || supabaseAnonKey === 'your_supabase_anon_key_here') {
        console.warn("Supabase URL or Anon Key is the placeholder. Please update .env file.");
        toast({ title: "Supabase Not Configured", description: "Using placeholder Supabase credentials. Please set up your Supabase URL and Anon Key in .env to connect to the database.", variant: "destructive", duration: 10000});
        setIsLoading(false);
        const localInitialTasks = initialTasksSeed.map((t, i) => ({
          ...t,
          id: uuidv4(), // Use uuid for local fallback
          createdAt: Date.now() - (initialTasksSeed.length - 1 - i) * 100000,
          orderIndex: i
        }));
        setTasks(localInitialTasks);
    } else { 
        console.warn("Supabase URL or Anon Key is not set or is invalid. Please update .env file.");
        toast({ title: "Supabase Not Configured", description: "Supabase is not configured. Tasks will not be saved. Please set up your Supabase credentials in .env.", variant: "destructive", duration: 10000});
        setIsLoading(false);
        const localInitialTasks = initialTasksSeed.map((t, i) => ({
          ...t,
          id: uuidv4(),
          createdAt: Date.now() - (initialTasksSeed.length - 1 - i) * 100000,
          orderIndex: i
        }));
        setTasks(localInitialTasks);
    }
  }, [loadTasksFromSupabase, toast]);

  const saveTaskOrderToSupabase = useCallback(async (tasksToSave: Task[]) => {
    // Used after drag-drop or smart schedule to update orderIndex
    setIsLoading(true);
    try {
      const updates = tasksToSave.map(task => 
        supabase
          .from(TASKS_TABLE)
          .update({ orderIndex: task.orderIndex })
          .eq('id', task.id)
      );
      const results = await Promise.all(updates);
      results.forEach(result => {
        if (result.error) throw result.error;
      });
      setTasks(tasksToSave); // Already locally updated
      toast({ title: "Tasks Order Saved", description: "Your task order has been saved to Supabase." });
    } catch (error) {
      console.error("Error saving task order to Supabase:", error);
      toast({ title: "Save Order Error", description: "Could not save task order to Supabase.", variant: "destructive" });
    } finally {
      setIsLoading(false);
    }
  }, [toast]);


  const handleAddTask = useCallback(async (description: string, estimatedTime: number) => {
    setIsLoading(true);
    const newTaskData = {
      description,
      estimatedCompletionTime: estimatedTime,
      priority: 'medium' as TaskPriority,
      completed: false,
      // createdAt will be handled by Supabase default
      orderIndex: tasks.length,
    };
    try {
      const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
      if (!supabaseUrl || supabaseUrl === 'your_supabase_url_here') {
        toast({ title: "Supabase Not Configured", description: "Cannot add task. Please configure Supabase.", variant: "destructive" });
        setIsLoading(false);
        return;
      }
      const { error } = await supabase.from(TASKS_TABLE).insert(newTaskData);
      if (error) throw error;
      
      toast({ title: "Task Added", description: `"${description}" has been added to Supabase.` });
      await loadTasksFromSupabase(); // Reload to get new ID and ensure consistency
    } catch (error) {
      console.error("Error adding task to Supabase:", error);
      toast({ title: "Add Error", description: "Could not add task to Supabase.", variant: "destructive" });
      setIsLoading(false); 
    }
  }, [tasks.length, toast, loadTasksFromSupabase]);

  const handleToggleComplete = useCallback(async (id: string) => {
    const task = tasks.find((t) => t.id === id);
    if (!task) return;
    const newCompletedStatus = !task.completed;
    try {
      const { error } = await supabase
        .from(TASKS_TABLE)
        .update({ completed: newCompletedStatus })
        .eq('id', id);
      if (error) throw error;

      setTasks((prevTasks) =>
        prevTasks.map((t) => (t.id === id ? { ...t, completed: newCompletedStatus } : t))
      );
      toast({ title: "Task Updated" });
    } catch (error) {
      console.error("Error updating task completion in Supabase:", error);
      toast({ title: "Update Error", description: "Could not update task in Supabase.", variant: "destructive" });
    }
  }, [tasks, toast]);

  const handleDeleteTask = useCallback(async (id: string) => {
    const taskToDelete = tasks.find(t => t.id === id);
    if (!taskToDelete) return;

    setIsLoading(true);
    try {
      const { error: deleteError } = await supabase
        .from(TASKS_TABLE)
        .delete()
        .eq('id', id);
      if (deleteError) throw deleteError;

      const remainingTasks = tasks.filter((task) => task.id !== id);
      const reorderedTasks = remainingTasks.map((task, index) => ({ ...task, orderIndex: index }));
      
      if (reorderedTasks.length > 0) {
        const updates = reorderedTasks.map(task => 
          supabase
            .from(TASKS_TABLE)
            .update({ orderIndex: task.orderIndex })
            .eq('id', task.id)
        );
        const results = await Promise.all(updates);
        results.forEach(result => {
          if (result.error) throw result.error; // Handle potential errors during re-indexing
        });
      }

      setTasks(reorderedTasks);
      toast({ title: "Task Deleted", description: `"${taskToDelete.description}" has been removed from Supabase.`, variant: "destructive" });
    } catch (error) {
      console.error("Error deleting task from Supabase:", error);
      toast({ title: "Delete Error", description: "Could not delete task from Supabase.", variant: "destructive" });
    } finally {
      setIsLoading(false);
    }
  }, [tasks, toast]);

  const handlePriorityChange = useCallback(async (id: string, priority: TaskPriority) => {
    try {
      const { error } = await supabase
        .from(TASKS_TABLE)
        .update({ priority: priority })
        .eq('id', id);
      if (error) throw error;

      setTasks((prevTasks) =>
        prevTasks.map((task) => (task.id === id ? { ...task, priority } : task))
      );
      toast({ title: "Priority Updated" });
    } catch (error) {
      console.error("Error updating task priority in Supabase:", error);
      toast({ title: "Update Error", description: "Could not update priority in Supabase.", variant: "destructive" });
    }
  }, [toast, tasks]);

  const handleSetTasks = useCallback(async (newTasks: Task[]) => {
    // This is called after drag & drop
    const tasksToSave = newTasks.map((task, index) => ({
      ...task,
      orderIndex: index,
    }));
    setTasks(tasksToSave); // Optimistic update locally
    await saveTaskOrderToSupabase(tasksToSave);
  }, [saveTaskOrderToSupabase]);

  const handleSmartSchedule = async () => {
    if (tasks.length === 0) {
      toast({ title: "No Tasks", description: "Add some tasks before trying to schedule.", variant: "destructive" });
      return;
    }
    setIsScheduling(true);
    try {
      const inputForAI: TaskListInput = {
        tasks: tasks.map(task => ({ // Ensure we send only necessary fields to AI
          id: task.id,
          description: task.description,
          estimatedCompletionTime: task.estimatedCompletionTime,
          priority: task.priority,
        })),
      };
      const result: TaskListOutput = await suggestOptimalTaskOrder(inputForAI);

      const newOrderedTasksFromAI = result.orderedTasks.map((aiTask, index) => {
        const originalTask = tasks.find(t => t.id === aiTask.id);
        return {
          ...originalTask!, // Spread original task to keep all its properties
          ...aiTask,       // Override with AI properties (like description, priority if changed by AI, and id)
          orderIndex: index,
          createdAt: originalTask?.createdAt || Date.now(), // Ensure createdAt is preserved
        };
      });
      
      // setTasks(newOrderedTasksFromAI); // Local state updated by saveTaskOrderToSupabase
      await saveTaskOrderToSupabase(newOrderedTasksFromAI);

      toast({
        title: "Schedule Optimized!",
        description: result.reasoning || "Tasks have been reordered for optimal flow.",
        duration: 7000,
      });
    } catch (error) {
      console.error("Error during smart scheduling with Supabase:", error);
      toast({
        title: "Scheduling Error",
        description: "Could not optimize the schedule. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsScheduling(false);
    }
  };

  if (!isClient || isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-background">
        <p className="text-foreground">{isLoading ? "Loading tasks..." : "Initializing Day Architect..."}</p>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background text-foreground">
      <main className="container mx-auto px-4 py-8 max-w-4xl">
        <AppHeader
          onSmartSchedule={handleSmartSchedule}
          isScheduling={isScheduling}
          onAddTask={handleAddTask}
        />

        <div className="grid grid-cols-1 sm:grid-cols-3 gap-8 mt-8">
          <div className="sm:col-span-2">
            <TaskList
              tasks={tasks}
              setTasks={handleSetTasks}
              onToggleComplete={handleToggleComplete}
              onDelete={handleDeleteTask}
              onPriorityChange={handlePriorityChange}
            />
          </div>
          <div className="sm:col-span-1">
            <ProgressIndicator tasks={tasks} />
          </div>
        </div>
      </main>
      <footer className="text-center py-6 text-sm text-muted-foreground border-t mt-12">
        <p>&copy; {new Date().getFullYear()} Day Architect. Plan your success.</p>
      </footer>
    </div>
  );
}
